prompts
"Generate commit messages based on code diffs. Provide concise and descriptive commit messages that accurately reflect the changes made in the code. Use appropriate language and conventions commonly used in commit messages. Your responses should only include commit messages, without any explanations or translations. Generate commit messages for the following code diffs. Here is the code diff: diff --git a/JavaCompilationHelper_old.java b/JavaCompilationHelper_new.java
index 08ca268..8791145 100644
--- a/JavaCompilationHelper_old.java
+++ b/JavaCompilationHelper_new.java
@@ -279,6 +279,8 @@ public final class JavaCompilationHelper extends BaseJavaCompilationHelper {
     builder.addDirectJars(attributes.getDirectJars());
     builder.setRuleKind(attributes.getRuleKind());
     builder.setTargetLabel(attributes.getTargetLabel());
+    builder.setJavaBaseInputs(getHostJavabaseInputsNonStatic(ruleContext));
+    builder.setJavacJar(getLangtoolsJar());
     builder.build();
 
     artifactBuilder.setCompileTimeDependencies(headerDeps);
diff --git a/JavaHeaderCompileActionBuilder_old.java b/JavaHeaderCompileActionBuilder_new.java
index 02d01cb..02b2a34 100644
--- a/JavaHeaderCompileActionBuilder_old.java
+++ b/JavaHeaderCompileActionBuilder_new.java
@@ -20,7 +20,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.devtools.build.lib.actions.Artifact;
 import com.google.devtools.build.lib.actions.ParameterFile.ParameterFileType;
 import com.google.devtools.build.lib.actions.ResourceSet;
-import com.google.devtools.build.lib.analysis.RuleConfiguredTarget.Mode;
 import com.google.devtools.build.lib.analysis.RuleContext;
 import com.google.devtools.build.lib.analysis.actions.CommandLine;
 import com.google.devtools.build.lib.analysis.actions.CustomCommandLine;
@@ -75,6 +74,8 @@ public class JavaHeaderCompileActionBuilder {
   private ImmutableList<String> javacOpts;
   private List<Artifact> processorPath = new ArrayList<>();
   private List<String> processorNames = new ArrayList<>();
+  private NestedSet<Artifact> javabaseInputs;
+  private Artifact javacJar;
 
   /** Creates a builder using the configuration of the rule as the action configuration. */
   public JavaHeaderCompileActionBuilder(RuleContext ruleContext) {
@@ -204,6 +205,20 @@ public class JavaHeaderCompileActionBuilder {
     return this;
   }
 
+  /** Sets the javabase inputs. */
+  public JavaHeaderCompileActionBuilder setJavaBaseInputs(NestedSet<Artifact> javabaseInputs) {
+    checkNotNull(javabaseInputs, ""javabaseInputs must not be null"");
+    this.javabaseInputs = javabaseInputs;
+    return this;
+  }
+
+  /** Sets the javac jar. */
+  public JavaHeaderCompileActionBuilder setJavacJar(Artifact javacJar) {
+    checkNotNull(javacJar, ""javacJar must not be null"");
+    this.javacJar = javacJar;
+    return this;
+  }
+
   /** Builds and registers the {@link SpawnAction} for a header compilation. */
   public void build() {
     checkNotNull(outputDepsProto, ""outputDepsProto must not be null"");
@@ -229,7 +244,7 @@ public class JavaHeaderCompileActionBuilder {
     builder.useParameterFile(ParameterFileType.SHELL_QUOTED);
     builder.setCommandLine(buildCommandLine(ruleContext.getConfiguration().getHostPathSeparator()));
 
-    builder.addTransitiveInputs(JavaHelper.getHostJavabaseInputs(ruleContext));
+    builder.addTransitiveInputs(javabaseInputs);
     builder.addInputs(classpathEntries);
     builder.addInputs(bootclasspathEntries);
     builder.addInputs(processorPath);
@@ -238,14 +253,13 @@ public class JavaHeaderCompileActionBuilder {
     builder.addInputs(directJars);
     builder.addInputs(compileTimeDependencyArtifacts);
 
-    Artifact langtools = ruleContext.getPrerequisiteArtifact(""$java_langtools"", Mode.HOST);
-    builder.addTool(langtools);
+    builder.addTool(javacJar);
 
     JavaToolchainProvider javaToolchain = JavaToolchainProvider.fromRuleContext(ruleContext);
     List<String> jvmArgs =
         ImmutableList.<String>builder()
             .addAll(javaToolchain.getJavacJvmOptions())
-            .add(""-Xbootclasspath/p:"" + langtools.getExecPath().getPathString())
+            .add(""-Xbootclasspath/p:"" + javacJar.getExecPath().getPathString())
             .build();
     builder.setJarExecutable(
         ruleContext.getHostConfiguration().getFragment(Jvm.class).getJavaExecutable(),
 This is the generated message: Update header compilation to handle implicit attribute suffixes

--
MOS_MIGRATED_REVID=117153381 Here is the code diff: diff --git a/BitmapFontCache_old.java b/BitmapFontCache_new.java
index 099c534..62fe276 100644
--- a/BitmapFontCache_old.java
+++ b/BitmapFontCache_new.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
@@ -47,8 +46,9 @@ public class BitmapFontCache {
 			return new ColorChunk();
 		}
 	};
+
 	private Array<ColorChunk> colorChunks;
-	
+
 	private int[] idx;
 	/** Used internally to ensure a correct capacity for multi-page font vertex data. */
 	private int[] tmpGlyphCount;
@@ -138,14 +138,12 @@ public class BitmapFontCache {
 		return color;
 	}
 
-	private int updateCurrentChunk(int lastChunkIndex, Color tint) {
+	private int updateCurrentChunk (int lastChunkIndex, Color tint) {
 		lastChunkIndex++;
 		if (colorChunks.size <= lastChunkIndex) {
-			if (colorChunks.size <= 0)
-				currentChunkColor.set(tint);
+			if (colorChunks.size <= 0) currentChunkColor.set(tint);
 			currentChunkEndIndex = Integer.MAX_VALUE;
-		}
-		else {
+		} else {
 			ColorChunk cc = colorChunks.get(lastChunkIndex);
 			if (currentChunkEndIndex == cc.endIndex)
 				lastChunkIndex = updateCurrentChunk(lastChunkIndex, tint);
@@ -166,7 +164,7 @@ public class BitmapFontCache {
 			if (font.markupEnabled) {
 				int lastChunkIndex = updateCurrentChunk(-1, tint);
 				float color = currentChunkColor.toFloatBits();
-				int ci = 0;  // character index
+				int ci = 0; // character index
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
@@ -177,15 +175,14 @@ public class BitmapFontCache {
 							}
 						}
 						vertices[i] = color;
-					}					
+					}
 				}
-			}
-			else {
+			} else {
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
 						vertices[i] = floatTint;
-					}					
+					}
 				}
 			}
 		}
@@ -520,8 +517,7 @@ public class BitmapFontCache {
 		Glyph lastGlyph = null;
 		BitmapFontData data = font.data;
 		textChanged = start < end;
-		if (font.markupEnabled && colorChunks.size == 0)
-			colorChunks.add(obtainColorChunk(this.color, -1));
+		if (font.markupEnabled && colorChunks.size == 0) colorChunks.add(obtainColorChunk(this.color, -1));
 		if (data.scaleX == 1 && data.scaleY == 1) {
 			while (start < end) {
 				char ch = str.charAt(start++);
@@ -870,11 +866,11 @@ public class BitmapFontCache {
 	public float[] getVertices (int page) {
 		return vertexData[page];
 	}
-	
+
 	private static class ColorChunk implements Poolable {
 		float color;
 		int endIndex;
-		int popIndex;  // needed to emulate the color stack
+		int popIndex; // needed to emulate the color stack
 
 		ColorChunk () {
 			this.endIndex = Integer.MAX_VALUE;
diff --git a/BitmapFontTest_old.java b/BitmapFontTest_new.java
index 3b193ac..637a21c 100644
--- a/BitmapFontTest_old.java
+++ b/BitmapFontTest_new.java
@@ -31,7 +31,6 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
-import com.badlogic.gdx.tests.g3d.BaseG3dHudTest.CollapsableWindow;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class BitmapFontTest extends GdxTest {
@@ -57,13 +56,14 @@ public class BitmapFontTest extends GdxTest {
 		stage = new Stage();
 
 		Skin skin = new Skin(Gdx.files.internal(""data/uiskin.json""));
-		
+
 		BitmapFont labelFont = skin.get(""default-font"", BitmapFont.class);
 		labelFont.setMarkupEnabled(true);
 
-		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations (they are silently ignored).
+		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
+		// They are silently ignored, as expected.
 		Label label = new Label(""<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][]>>"", skin);
-		
+
 		label.setPosition(200, 200);
 		stage.addActor(label);
 
@@ -146,7 +146,7 @@ public class BitmapFontTest extends GdxTest {
 		renderer.setColor(Color.BLACK);
 		renderer.rect(x, viewHeight - y, x + alignmentWidth, 300);
 		renderer.end();
-		
+
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
 	}
 This is the generated message: Code formatted and imports organized. Here is the code diff: diff --git a/BazelCppRuleClasses_old.java b/BazelCppRuleClasses_new.java
index 9363b34..7115da9 100644
--- a/BazelCppRuleClasses_old.java
+++ b/BazelCppRuleClasses_new.java
@@ -259,8 +259,7 @@ public class BazelCppRuleClasses {
           so be careful about header files included elsewhere.</p>
           <!-- #END_BLAZE_RULE.ATTRIBUTE -->*/
           .add(attr(""copts"", STRING_LIST))
-          .add(attr(""$stl"", LABEL).value(
-              env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"")))
+          .add(attr(""$stl"", LABEL).value(env.getLabel(""//tools/cpp:stl"")))
           .add(attr("":stl"", LABEL).value(STL))
           .build();
     }
@@ -533,7 +532,7 @@ public class BazelCppRuleClasses {
               // Every cc_rule depends implicitly on STL to make
               // sure that the correct headers are used for inclusion. The only exception is
               // STL itself to avoid cycles in the dependency graph.
-              Label stl = env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"");
+              Label stl = env.getLabel(""//tools/cpp:stl"");
               return rule.getLabel().equals(stl) ? null : stl;
             }
           }))
 This is the generated message: Fix broken resolution of STL sources through @bazel_tools.

Includes an integration test for bazel + stl and objc -> cc deps.

Based on patched work by cparsons@.

--
MOS_MIGRATED_REVID=106946039 Here is the code diff: diff --git a/ServerAdmin_old.java b/ServerAdmin_new.java
index e52711e..f5f3580 100644
--- a/ServerAdmin_old.java
+++ b/ServerAdmin_new.java
@@ -487,12 +487,12 @@ public class ServerAdmin implements GhidraLaunchable {
 		System.err.println(""\nSupported commands:"");
 		System.err.println(""  -add <sid> [--p]"");
 		System.err.println(
-			""      Add a new user to the server identified by their sid identifier [-p prompt for password]"");
+			""      Add a new user to the server identified by their sid identifier [--p prompt for password]"");
 		System.err.println(""  -remove <sid>"");
 		System.err.println(""      Remove the specified user from the server's user list"");
 		System.err.println(""  -reset <sid> [--p]"");
 		System.err.println(
-			""      Reset the specified user's server login password [-p prompt for password]"");
+			""      Reset the specified user's server login password [--p prompt for password]"");
 		System.err.println(""  -dn <sid> \""<dname>\"""");
 		System.err.println(
 			""      When PKI authentication is used, add the specified X500 Distinguished Name for a user"");
 This is the generated message: GT-360 corrected usage text Here is the code diff: diff --git a/Launcher_old.java b/Launcher_new.java
index 2511a96..c69a55f 100644
--- a/Launcher_old.java
+++ b/Launcher_new.java
@@ -103,7 +103,10 @@ public abstract class Launcher {
         StringBuffer buf = new StringBuffer();
         if (workDir != null) {
             buf.append('[');
-            buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
+            if(showFullPath)
+                buf.append(workDir.getRemote());
+            else
+                buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
             buf.append(""] "");
         }
         buf.append('$');
@@ -144,4 +147,9 @@ public abstract class Launcher {
             return m;
         }
     }
+
+    /**
+     * Debug option to display full current path instead of just the last token.
+     */
+    public static boolean showFullPath = false;
 }
 This is the generated message:"
"Generate commit messages for code diffs based on the changes made. Here is the code diff: diff --git a/JavaCompilationHelper_old.java b/JavaCompilationHelper_new.java
index 08ca268..8791145 100644
--- a/JavaCompilationHelper_old.java
+++ b/JavaCompilationHelper_new.java
@@ -279,6 +279,8 @@ public final class JavaCompilationHelper extends BaseJavaCompilationHelper {
     builder.addDirectJars(attributes.getDirectJars());
     builder.setRuleKind(attributes.getRuleKind());
     builder.setTargetLabel(attributes.getTargetLabel());
+    builder.setJavaBaseInputs(getHostJavabaseInputsNonStatic(ruleContext));
+    builder.setJavacJar(getLangtoolsJar());
     builder.build();
 
     artifactBuilder.setCompileTimeDependencies(headerDeps);
diff --git a/JavaHeaderCompileActionBuilder_old.java b/JavaHeaderCompileActionBuilder_new.java
index 02d01cb..02b2a34 100644
--- a/JavaHeaderCompileActionBuilder_old.java
+++ b/JavaHeaderCompileActionBuilder_new.java
@@ -20,7 +20,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.devtools.build.lib.actions.Artifact;
 import com.google.devtools.build.lib.actions.ParameterFile.ParameterFileType;
 import com.google.devtools.build.lib.actions.ResourceSet;
-import com.google.devtools.build.lib.analysis.RuleConfiguredTarget.Mode;
 import com.google.devtools.build.lib.analysis.RuleContext;
 import com.google.devtools.build.lib.analysis.actions.CommandLine;
 import com.google.devtools.build.lib.analysis.actions.CustomCommandLine;
@@ -75,6 +74,8 @@ public class JavaHeaderCompileActionBuilder {
   private ImmutableList<String> javacOpts;
   private List<Artifact> processorPath = new ArrayList<>();
   private List<String> processorNames = new ArrayList<>();
+  private NestedSet<Artifact> javabaseInputs;
+  private Artifact javacJar;
 
   /** Creates a builder using the configuration of the rule as the action configuration. */
   public JavaHeaderCompileActionBuilder(RuleContext ruleContext) {
@@ -204,6 +205,20 @@ public class JavaHeaderCompileActionBuilder {
     return this;
   }
 
+  /** Sets the javabase inputs. */
+  public JavaHeaderCompileActionBuilder setJavaBaseInputs(NestedSet<Artifact> javabaseInputs) {
+    checkNotNull(javabaseInputs, ""javabaseInputs must not be null"");
+    this.javabaseInputs = javabaseInputs;
+    return this;
+  }
+
+  /** Sets the javac jar. */
+  public JavaHeaderCompileActionBuilder setJavacJar(Artifact javacJar) {
+    checkNotNull(javacJar, ""javacJar must not be null"");
+    this.javacJar = javacJar;
+    return this;
+  }
+
   /** Builds and registers the {@link SpawnAction} for a header compilation. */
   public void build() {
     checkNotNull(outputDepsProto, ""outputDepsProto must not be null"");
@@ -229,7 +244,7 @@ public class JavaHeaderCompileActionBuilder {
     builder.useParameterFile(ParameterFileType.SHELL_QUOTED);
     builder.setCommandLine(buildCommandLine(ruleContext.getConfiguration().getHostPathSeparator()));
 
-    builder.addTransitiveInputs(JavaHelper.getHostJavabaseInputs(ruleContext));
+    builder.addTransitiveInputs(javabaseInputs);
     builder.addInputs(classpathEntries);
     builder.addInputs(bootclasspathEntries);
     builder.addInputs(processorPath);
@@ -238,14 +253,13 @@ public class JavaHeaderCompileActionBuilder {
     builder.addInputs(directJars);
     builder.addInputs(compileTimeDependencyArtifacts);
 
-    Artifact langtools = ruleContext.getPrerequisiteArtifact(""$java_langtools"", Mode.HOST);
-    builder.addTool(langtools);
+    builder.addTool(javacJar);
 
     JavaToolchainProvider javaToolchain = JavaToolchainProvider.fromRuleContext(ruleContext);
     List<String> jvmArgs =
         ImmutableList.<String>builder()
             .addAll(javaToolchain.getJavacJvmOptions())
-            .add(""-Xbootclasspath/p:"" + langtools.getExecPath().getPathString())
+            .add(""-Xbootclasspath/p:"" + javacJar.getExecPath().getPathString())
             .build();
     builder.setJarExecutable(
         ruleContext.getHostConfiguration().getFragment(Jvm.class).getJavaExecutable(),
 This is the generated message: Update header compilation to handle implicit attribute suffixes

--
MOS_MIGRATED_REVID=117153381 Here is the code diff: diff --git a/BitmapFontCache_old.java b/BitmapFontCache_new.java
index 099c534..62fe276 100644
--- a/BitmapFontCache_old.java
+++ b/BitmapFontCache_new.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
@@ -47,8 +46,9 @@ public class BitmapFontCache {
 			return new ColorChunk();
 		}
 	};
+
 	private Array<ColorChunk> colorChunks;
-	
+
 	private int[] idx;
 	/** Used internally to ensure a correct capacity for multi-page font vertex data. */
 	private int[] tmpGlyphCount;
@@ -138,14 +138,12 @@ public class BitmapFontCache {
 		return color;
 	}
 
-	private int updateCurrentChunk(int lastChunkIndex, Color tint) {
+	private int updateCurrentChunk (int lastChunkIndex, Color tint) {
 		lastChunkIndex++;
 		if (colorChunks.size <= lastChunkIndex) {
-			if (colorChunks.size <= 0)
-				currentChunkColor.set(tint);
+			if (colorChunks.size <= 0) currentChunkColor.set(tint);
 			currentChunkEndIndex = Integer.MAX_VALUE;
-		}
-		else {
+		} else {
 			ColorChunk cc = colorChunks.get(lastChunkIndex);
 			if (currentChunkEndIndex == cc.endIndex)
 				lastChunkIndex = updateCurrentChunk(lastChunkIndex, tint);
@@ -166,7 +164,7 @@ public class BitmapFontCache {
 			if (font.markupEnabled) {
 				int lastChunkIndex = updateCurrentChunk(-1, tint);
 				float color = currentChunkColor.toFloatBits();
-				int ci = 0;  // character index
+				int ci = 0; // character index
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
@@ -177,15 +175,14 @@ public class BitmapFontCache {
 							}
 						}
 						vertices[i] = color;
-					}					
+					}
 				}
-			}
-			else {
+			} else {
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
 						vertices[i] = floatTint;
-					}					
+					}
 				}
 			}
 		}
@@ -520,8 +517,7 @@ public class BitmapFontCache {
 		Glyph lastGlyph = null;
 		BitmapFontData data = font.data;
 		textChanged = start < end;
-		if (font.markupEnabled && colorChunks.size == 0)
-			colorChunks.add(obtainColorChunk(this.color, -1));
+		if (font.markupEnabled && colorChunks.size == 0) colorChunks.add(obtainColorChunk(this.color, -1));
 		if (data.scaleX == 1 && data.scaleY == 1) {
 			while (start < end) {
 				char ch = str.charAt(start++);
@@ -870,11 +866,11 @@ public class BitmapFontCache {
 	public float[] getVertices (int page) {
 		return vertexData[page];
 	}
-	
+
 	private static class ColorChunk implements Poolable {
 		float color;
 		int endIndex;
-		int popIndex;  // needed to emulate the color stack
+		int popIndex; // needed to emulate the color stack
 
 		ColorChunk () {
 			this.endIndex = Integer.MAX_VALUE;
diff --git a/BitmapFontTest_old.java b/BitmapFontTest_new.java
index 3b193ac..637a21c 100644
--- a/BitmapFontTest_old.java
+++ b/BitmapFontTest_new.java
@@ -31,7 +31,6 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
-import com.badlogic.gdx.tests.g3d.BaseG3dHudTest.CollapsableWindow;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class BitmapFontTest extends GdxTest {
@@ -57,13 +56,14 @@ public class BitmapFontTest extends GdxTest {
 		stage = new Stage();
 
 		Skin skin = new Skin(Gdx.files.internal(""data/uiskin.json""));
-		
+
 		BitmapFont labelFont = skin.get(""default-font"", BitmapFont.class);
 		labelFont.setMarkupEnabled(true);
 
-		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations (they are silently ignored).
+		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
+		// They are silently ignored, as expected.
 		Label label = new Label(""<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][]>>"", skin);
-		
+
 		label.setPosition(200, 200);
 		stage.addActor(label);
 
@@ -146,7 +146,7 @@ public class BitmapFontTest extends GdxTest {
 		renderer.setColor(Color.BLACK);
 		renderer.rect(x, viewHeight - y, x + alignmentWidth, 300);
 		renderer.end();
-		
+
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
 	}
 This is the generated message: Code formatted and imports organized. Here is the code diff: diff --git a/BazelCppRuleClasses_old.java b/BazelCppRuleClasses_new.java
index 9363b34..7115da9 100644
--- a/BazelCppRuleClasses_old.java
+++ b/BazelCppRuleClasses_new.java
@@ -259,8 +259,7 @@ public class BazelCppRuleClasses {
           so be careful about header files included elsewhere.</p>
           <!-- #END_BLAZE_RULE.ATTRIBUTE -->*/
           .add(attr(""copts"", STRING_LIST))
-          .add(attr(""$stl"", LABEL).value(
-              env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"")))
+          .add(attr(""$stl"", LABEL).value(env.getLabel(""//tools/cpp:stl"")))
           .add(attr("":stl"", LABEL).value(STL))
           .build();
     }
@@ -533,7 +532,7 @@ public class BazelCppRuleClasses {
               // Every cc_rule depends implicitly on STL to make
               // sure that the correct headers are used for inclusion. The only exception is
               // STL itself to avoid cycles in the dependency graph.
-              Label stl = env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"");
+              Label stl = env.getLabel(""//tools/cpp:stl"");
               return rule.getLabel().equals(stl) ? null : stl;
             }
           }))
 This is the generated message: Fix broken resolution of STL sources through @bazel_tools.

Includes an integration test for bazel + stl and objc -> cc deps.

Based on patched work by cparsons@.

--
MOS_MIGRATED_REVID=106946039 Here is the code diff: diff --git a/ServerAdmin_old.java b/ServerAdmin_new.java
index e52711e..f5f3580 100644
--- a/ServerAdmin_old.java
+++ b/ServerAdmin_new.java
@@ -487,12 +487,12 @@ public class ServerAdmin implements GhidraLaunchable {
 		System.err.println(""\nSupported commands:"");
 		System.err.println(""  -add <sid> [--p]"");
 		System.err.println(
-			""      Add a new user to the server identified by their sid identifier [-p prompt for password]"");
+			""      Add a new user to the server identified by their sid identifier [--p prompt for password]"");
 		System.err.println(""  -remove <sid>"");
 		System.err.println(""      Remove the specified user from the server's user list"");
 		System.err.println(""  -reset <sid> [--p]"");
 		System.err.println(
-			""      Reset the specified user's server login password [-p prompt for password]"");
+			""      Reset the specified user's server login password [--p prompt for password]"");
 		System.err.println(""  -dn <sid> \""<dname>\"""");
 		System.err.println(
 			""      When PKI authentication is used, add the specified X500 Distinguished Name for a user"");
 This is the generated message: GT-360 corrected usage text Here is the code diff: diff --git a/Launcher_old.java b/Launcher_new.java
index 2511a96..c69a55f 100644
--- a/Launcher_old.java
+++ b/Launcher_new.java
@@ -103,7 +103,10 @@ public abstract class Launcher {
         StringBuffer buf = new StringBuffer();
         if (workDir != null) {
             buf.append('[');
-            buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
+            if(showFullPath)
+                buf.append(workDir.getRemote());
+            else
+                buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
             buf.append(""] "");
         }
         buf.append('$');
@@ -144,4 +147,9 @@ public abstract class Launcher {
             return m;
         }
     }
+
+    /**
+     * Debug option to display full current path instead of just the last token.
+     */
+    public static boolean showFullPath = false;
 }
 This is the generated message:"
"You are tasked with creating a commit message for the given code diff. The message should be informative, concise, and follow the conventional commit message format. Please do not include any additional explanations or translations. Here is the code diff: diff --git a/JavaCompilationHelper_old.java b/JavaCompilationHelper_new.java
index 08ca268..8791145 100644
--- a/JavaCompilationHelper_old.java
+++ b/JavaCompilationHelper_new.java
@@ -279,6 +279,8 @@ public final class JavaCompilationHelper extends BaseJavaCompilationHelper {
     builder.addDirectJars(attributes.getDirectJars());
     builder.setRuleKind(attributes.getRuleKind());
     builder.setTargetLabel(attributes.getTargetLabel());
+    builder.setJavaBaseInputs(getHostJavabaseInputsNonStatic(ruleContext));
+    builder.setJavacJar(getLangtoolsJar());
     builder.build();
 
     artifactBuilder.setCompileTimeDependencies(headerDeps);
diff --git a/JavaHeaderCompileActionBuilder_old.java b/JavaHeaderCompileActionBuilder_new.java
index 02d01cb..02b2a34 100644
--- a/JavaHeaderCompileActionBuilder_old.java
+++ b/JavaHeaderCompileActionBuilder_new.java
@@ -20,7 +20,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.devtools.build.lib.actions.Artifact;
 import com.google.devtools.build.lib.actions.ParameterFile.ParameterFileType;
 import com.google.devtools.build.lib.actions.ResourceSet;
-import com.google.devtools.build.lib.analysis.RuleConfiguredTarget.Mode;
 import com.google.devtools.build.lib.analysis.RuleContext;
 import com.google.devtools.build.lib.analysis.actions.CommandLine;
 import com.google.devtools.build.lib.analysis.actions.CustomCommandLine;
@@ -75,6 +74,8 @@ public class JavaHeaderCompileActionBuilder {
   private ImmutableList<String> javacOpts;
   private List<Artifact> processorPath = new ArrayList<>();
   private List<String> processorNames = new ArrayList<>();
+  private NestedSet<Artifact> javabaseInputs;
+  private Artifact javacJar;
 
   /** Creates a builder using the configuration of the rule as the action configuration. */
   public JavaHeaderCompileActionBuilder(RuleContext ruleContext) {
@@ -204,6 +205,20 @@ public class JavaHeaderCompileActionBuilder {
     return this;
   }
 
+  /** Sets the javabase inputs. */
+  public JavaHeaderCompileActionBuilder setJavaBaseInputs(NestedSet<Artifact> javabaseInputs) {
+    checkNotNull(javabaseInputs, ""javabaseInputs must not be null"");
+    this.javabaseInputs = javabaseInputs;
+    return this;
+  }
+
+  /** Sets the javac jar. */
+  public JavaHeaderCompileActionBuilder setJavacJar(Artifact javacJar) {
+    checkNotNull(javacJar, ""javacJar must not be null"");
+    this.javacJar = javacJar;
+    return this;
+  }
+
   /** Builds and registers the {@link SpawnAction} for a header compilation. */
   public void build() {
     checkNotNull(outputDepsProto, ""outputDepsProto must not be null"");
@@ -229,7 +244,7 @@ public class JavaHeaderCompileActionBuilder {
     builder.useParameterFile(ParameterFileType.SHELL_QUOTED);
     builder.setCommandLine(buildCommandLine(ruleContext.getConfiguration().getHostPathSeparator()));
 
-    builder.addTransitiveInputs(JavaHelper.getHostJavabaseInputs(ruleContext));
+    builder.addTransitiveInputs(javabaseInputs);
     builder.addInputs(classpathEntries);
     builder.addInputs(bootclasspathEntries);
     builder.addInputs(processorPath);
@@ -238,14 +253,13 @@ public class JavaHeaderCompileActionBuilder {
     builder.addInputs(directJars);
     builder.addInputs(compileTimeDependencyArtifacts);
 
-    Artifact langtools = ruleContext.getPrerequisiteArtifact(""$java_langtools"", Mode.HOST);
-    builder.addTool(langtools);
+    builder.addTool(javacJar);
 
     JavaToolchainProvider javaToolchain = JavaToolchainProvider.fromRuleContext(ruleContext);
     List<String> jvmArgs =
         ImmutableList.<String>builder()
             .addAll(javaToolchain.getJavacJvmOptions())
-            .add(""-Xbootclasspath/p:"" + langtools.getExecPath().getPathString())
+            .add(""-Xbootclasspath/p:"" + javacJar.getExecPath().getPathString())
             .build();
     builder.setJarExecutable(
         ruleContext.getHostConfiguration().getFragment(Jvm.class).getJavaExecutable(),
 This is the generated message: Update header compilation to handle implicit attribute suffixes

--
MOS_MIGRATED_REVID=117153381 Here is the code diff: diff --git a/BitmapFontCache_old.java b/BitmapFontCache_new.java
index 099c534..62fe276 100644
--- a/BitmapFontCache_old.java
+++ b/BitmapFontCache_new.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
@@ -47,8 +46,9 @@ public class BitmapFontCache {
 			return new ColorChunk();
 		}
 	};
+
 	private Array<ColorChunk> colorChunks;
-	
+
 	private int[] idx;
 	/** Used internally to ensure a correct capacity for multi-page font vertex data. */
 	private int[] tmpGlyphCount;
@@ -138,14 +138,12 @@ public class BitmapFontCache {
 		return color;
 	}
 
-	private int updateCurrentChunk(int lastChunkIndex, Color tint) {
+	private int updateCurrentChunk (int lastChunkIndex, Color tint) {
 		lastChunkIndex++;
 		if (colorChunks.size <= lastChunkIndex) {
-			if (colorChunks.size <= 0)
-				currentChunkColor.set(tint);
+			if (colorChunks.size <= 0) currentChunkColor.set(tint);
 			currentChunkEndIndex = Integer.MAX_VALUE;
-		}
-		else {
+		} else {
 			ColorChunk cc = colorChunks.get(lastChunkIndex);
 			if (currentChunkEndIndex == cc.endIndex)
 				lastChunkIndex = updateCurrentChunk(lastChunkIndex, tint);
@@ -166,7 +164,7 @@ public class BitmapFontCache {
 			if (font.markupEnabled) {
 				int lastChunkIndex = updateCurrentChunk(-1, tint);
 				float color = currentChunkColor.toFloatBits();
-				int ci = 0;  // character index
+				int ci = 0; // character index
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
@@ -177,15 +175,14 @@ public class BitmapFontCache {
 							}
 						}
 						vertices[i] = color;
-					}					
+					}
 				}
-			}
-			else {
+			} else {
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
 						vertices[i] = floatTint;
-					}					
+					}
 				}
 			}
 		}
@@ -520,8 +517,7 @@ public class BitmapFontCache {
 		Glyph lastGlyph = null;
 		BitmapFontData data = font.data;
 		textChanged = start < end;
-		if (font.markupEnabled && colorChunks.size == 0)
-			colorChunks.add(obtainColorChunk(this.color, -1));
+		if (font.markupEnabled && colorChunks.size == 0) colorChunks.add(obtainColorChunk(this.color, -1));
 		if (data.scaleX == 1 && data.scaleY == 1) {
 			while (start < end) {
 				char ch = str.charAt(start++);
@@ -870,11 +866,11 @@ public class BitmapFontCache {
 	public float[] getVertices (int page) {
 		return vertexData[page];
 	}
-	
+
 	private static class ColorChunk implements Poolable {
 		float color;
 		int endIndex;
-		int popIndex;  // needed to emulate the color stack
+		int popIndex; // needed to emulate the color stack
 
 		ColorChunk () {
 			this.endIndex = Integer.MAX_VALUE;
diff --git a/BitmapFontTest_old.java b/BitmapFontTest_new.java
index 3b193ac..637a21c 100644
--- a/BitmapFontTest_old.java
+++ b/BitmapFontTest_new.java
@@ -31,7 +31,6 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
-import com.badlogic.gdx.tests.g3d.BaseG3dHudTest.CollapsableWindow;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class BitmapFontTest extends GdxTest {
@@ -57,13 +56,14 @@ public class BitmapFontTest extends GdxTest {
 		stage = new Stage();
 
 		Skin skin = new Skin(Gdx.files.internal(""data/uiskin.json""));
-		
+
 		BitmapFont labelFont = skin.get(""default-font"", BitmapFont.class);
 		labelFont.setMarkupEnabled(true);
 
-		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations (they are silently ignored).
+		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
+		// They are silently ignored, as expected.
 		Label label = new Label(""<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][]>>"", skin);
-		
+
 		label.setPosition(200, 200);
 		stage.addActor(label);
 
@@ -146,7 +146,7 @@ public class BitmapFontTest extends GdxTest {
 		renderer.setColor(Color.BLACK);
 		renderer.rect(x, viewHeight - y, x + alignmentWidth, 300);
 		renderer.end();
-		
+
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
 	}
 This is the generated message: Code formatted and imports organized. Here is the code diff: diff --git a/BazelCppRuleClasses_old.java b/BazelCppRuleClasses_new.java
index 9363b34..7115da9 100644
--- a/BazelCppRuleClasses_old.java
+++ b/BazelCppRuleClasses_new.java
@@ -259,8 +259,7 @@ public class BazelCppRuleClasses {
           so be careful about header files included elsewhere.</p>
           <!-- #END_BLAZE_RULE.ATTRIBUTE -->*/
           .add(attr(""copts"", STRING_LIST))
-          .add(attr(""$stl"", LABEL).value(
-              env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"")))
+          .add(attr(""$stl"", LABEL).value(env.getLabel(""//tools/cpp:stl"")))
           .add(attr("":stl"", LABEL).value(STL))
           .build();
     }
@@ -533,7 +532,7 @@ public class BazelCppRuleClasses {
               // Every cc_rule depends implicitly on STL to make
               // sure that the correct headers are used for inclusion. The only exception is
               // STL itself to avoid cycles in the dependency graph.
-              Label stl = env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"");
+              Label stl = env.getLabel(""//tools/cpp:stl"");
               return rule.getLabel().equals(stl) ? null : stl;
             }
           }))
 This is the generated message: Fix broken resolution of STL sources through @bazel_tools.

Includes an integration test for bazel + stl and objc -> cc deps.

Based on patched work by cparsons@.

--
MOS_MIGRATED_REVID=106946039 Here is the code diff: diff --git a/ServerAdmin_old.java b/ServerAdmin_new.java
index e52711e..f5f3580 100644
--- a/ServerAdmin_old.java
+++ b/ServerAdmin_new.java
@@ -487,12 +487,12 @@ public class ServerAdmin implements GhidraLaunchable {
 		System.err.println(""\nSupported commands:"");
 		System.err.println(""  -add <sid> [--p]"");
 		System.err.println(
-			""      Add a new user to the server identified by their sid identifier [-p prompt for password]"");
+			""      Add a new user to the server identified by their sid identifier [--p prompt for password]"");
 		System.err.println(""  -remove <sid>"");
 		System.err.println(""      Remove the specified user from the server's user list"");
 		System.err.println(""  -reset <sid> [--p]"");
 		System.err.println(
-			""      Reset the specified user's server login password [-p prompt for password]"");
+			""      Reset the specified user's server login password [--p prompt for password]"");
 		System.err.println(""  -dn <sid> \""<dname>\"""");
 		System.err.println(
 			""      When PKI authentication is used, add the specified X500 Distinguished Name for a user"");
 This is the generated message: GT-360 corrected usage text Here is the code diff: diff --git a/Launcher_old.java b/Launcher_new.java
index 2511a96..c69a55f 100644
--- a/Launcher_old.java
+++ b/Launcher_new.java
@@ -103,7 +103,10 @@ public abstract class Launcher {
         StringBuffer buf = new StringBuffer();
         if (workDir != null) {
             buf.append('[');
-            buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
+            if(showFullPath)
+                buf.append(workDir.getRemote());
+            else
+                buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
             buf.append(""] "");
         }
         buf.append('$');
@@ -144,4 +147,9 @@ public abstract class Launcher {
             return m;
         }
     }
+
+    /**
+     * Debug option to display full current path instead of just the last token.
+     */
+    public static boolean showFullPath = false;
 }
 This is the generated message:"
"Generate a commit message for the given code diff that accurately reflects the changes made. The message should be clear, concise, and follow the standard conventions used in commit messages. Here is the code diff: diff --git a/JavaCompilationHelper_old.java b/JavaCompilationHelper_new.java
index 08ca268..8791145 100644
--- a/JavaCompilationHelper_old.java
+++ b/JavaCompilationHelper_new.java
@@ -279,6 +279,8 @@ public final class JavaCompilationHelper extends BaseJavaCompilationHelper {
     builder.addDirectJars(attributes.getDirectJars());
     builder.setRuleKind(attributes.getRuleKind());
     builder.setTargetLabel(attributes.getTargetLabel());
+    builder.setJavaBaseInputs(getHostJavabaseInputsNonStatic(ruleContext));
+    builder.setJavacJar(getLangtoolsJar());
     builder.build();
 
     artifactBuilder.setCompileTimeDependencies(headerDeps);
diff --git a/JavaHeaderCompileActionBuilder_old.java b/JavaHeaderCompileActionBuilder_new.java
index 02d01cb..02b2a34 100644
--- a/JavaHeaderCompileActionBuilder_old.java
+++ b/JavaHeaderCompileActionBuilder_new.java
@@ -20,7 +20,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.devtools.build.lib.actions.Artifact;
 import com.google.devtools.build.lib.actions.ParameterFile.ParameterFileType;
 import com.google.devtools.build.lib.actions.ResourceSet;
-import com.google.devtools.build.lib.analysis.RuleConfiguredTarget.Mode;
 import com.google.devtools.build.lib.analysis.RuleContext;
 import com.google.devtools.build.lib.analysis.actions.CommandLine;
 import com.google.devtools.build.lib.analysis.actions.CustomCommandLine;
@@ -75,6 +74,8 @@ public class JavaHeaderCompileActionBuilder {
   private ImmutableList<String> javacOpts;
   private List<Artifact> processorPath = new ArrayList<>();
   private List<String> processorNames = new ArrayList<>();
+  private NestedSet<Artifact> javabaseInputs;
+  private Artifact javacJar;
 
   /** Creates a builder using the configuration of the rule as the action configuration. */
   public JavaHeaderCompileActionBuilder(RuleContext ruleContext) {
@@ -204,6 +205,20 @@ public class JavaHeaderCompileActionBuilder {
     return this;
   }
 
+  /** Sets the javabase inputs. */
+  public JavaHeaderCompileActionBuilder setJavaBaseInputs(NestedSet<Artifact> javabaseInputs) {
+    checkNotNull(javabaseInputs, ""javabaseInputs must not be null"");
+    this.javabaseInputs = javabaseInputs;
+    return this;
+  }
+
+  /** Sets the javac jar. */
+  public JavaHeaderCompileActionBuilder setJavacJar(Artifact javacJar) {
+    checkNotNull(javacJar, ""javacJar must not be null"");
+    this.javacJar = javacJar;
+    return this;
+  }
+
   /** Builds and registers the {@link SpawnAction} for a header compilation. */
   public void build() {
     checkNotNull(outputDepsProto, ""outputDepsProto must not be null"");
@@ -229,7 +244,7 @@ public class JavaHeaderCompileActionBuilder {
     builder.useParameterFile(ParameterFileType.SHELL_QUOTED);
     builder.setCommandLine(buildCommandLine(ruleContext.getConfiguration().getHostPathSeparator()));
 
-    builder.addTransitiveInputs(JavaHelper.getHostJavabaseInputs(ruleContext));
+    builder.addTransitiveInputs(javabaseInputs);
     builder.addInputs(classpathEntries);
     builder.addInputs(bootclasspathEntries);
     builder.addInputs(processorPath);
@@ -238,14 +253,13 @@ public class JavaHeaderCompileActionBuilder {
     builder.addInputs(directJars);
     builder.addInputs(compileTimeDependencyArtifacts);
 
-    Artifact langtools = ruleContext.getPrerequisiteArtifact(""$java_langtools"", Mode.HOST);
-    builder.addTool(langtools);
+    builder.addTool(javacJar);
 
     JavaToolchainProvider javaToolchain = JavaToolchainProvider.fromRuleContext(ruleContext);
     List<String> jvmArgs =
         ImmutableList.<String>builder()
             .addAll(javaToolchain.getJavacJvmOptions())
-            .add(""-Xbootclasspath/p:"" + langtools.getExecPath().getPathString())
+            .add(""-Xbootclasspath/p:"" + javacJar.getExecPath().getPathString())
             .build();
     builder.setJarExecutable(
         ruleContext.getHostConfiguration().getFragment(Jvm.class).getJavaExecutable(),
 This is the generated message: Update header compilation to handle implicit attribute suffixes

--
MOS_MIGRATED_REVID=117153381 Here is the code diff: diff --git a/BitmapFontCache_old.java b/BitmapFontCache_new.java
index 099c534..62fe276 100644
--- a/BitmapFontCache_old.java
+++ b/BitmapFontCache_new.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
@@ -47,8 +46,9 @@ public class BitmapFontCache {
 			return new ColorChunk();
 		}
 	};
+
 	private Array<ColorChunk> colorChunks;
-	
+
 	private int[] idx;
 	/** Used internally to ensure a correct capacity for multi-page font vertex data. */
 	private int[] tmpGlyphCount;
@@ -138,14 +138,12 @@ public class BitmapFontCache {
 		return color;
 	}
 
-	private int updateCurrentChunk(int lastChunkIndex, Color tint) {
+	private int updateCurrentChunk (int lastChunkIndex, Color tint) {
 		lastChunkIndex++;
 		if (colorChunks.size <= lastChunkIndex) {
-			if (colorChunks.size <= 0)
-				currentChunkColor.set(tint);
+			if (colorChunks.size <= 0) currentChunkColor.set(tint);
 			currentChunkEndIndex = Integer.MAX_VALUE;
-		}
-		else {
+		} else {
 			ColorChunk cc = colorChunks.get(lastChunkIndex);
 			if (currentChunkEndIndex == cc.endIndex)
 				lastChunkIndex = updateCurrentChunk(lastChunkIndex, tint);
@@ -166,7 +164,7 @@ public class BitmapFontCache {
 			if (font.markupEnabled) {
 				int lastChunkIndex = updateCurrentChunk(-1, tint);
 				float color = currentChunkColor.toFloatBits();
-				int ci = 0;  // character index
+				int ci = 0; // character index
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
@@ -177,15 +175,14 @@ public class BitmapFontCache {
 							}
 						}
 						vertices[i] = color;
-					}					
+					}
 				}
-			}
-			else {
+			} else {
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
 						vertices[i] = floatTint;
-					}					
+					}
 				}
 			}
 		}
@@ -520,8 +517,7 @@ public class BitmapFontCache {
 		Glyph lastGlyph = null;
 		BitmapFontData data = font.data;
 		textChanged = start < end;
-		if (font.markupEnabled && colorChunks.size == 0)
-			colorChunks.add(obtainColorChunk(this.color, -1));
+		if (font.markupEnabled && colorChunks.size == 0) colorChunks.add(obtainColorChunk(this.color, -1));
 		if (data.scaleX == 1 && data.scaleY == 1) {
 			while (start < end) {
 				char ch = str.charAt(start++);
@@ -870,11 +866,11 @@ public class BitmapFontCache {
 	public float[] getVertices (int page) {
 		return vertexData[page];
 	}
-	
+
 	private static class ColorChunk implements Poolable {
 		float color;
 		int endIndex;
-		int popIndex;  // needed to emulate the color stack
+		int popIndex; // needed to emulate the color stack
 
 		ColorChunk () {
 			this.endIndex = Integer.MAX_VALUE;
diff --git a/BitmapFontTest_old.java b/BitmapFontTest_new.java
index 3b193ac..637a21c 100644
--- a/BitmapFontTest_old.java
+++ b/BitmapFontTest_new.java
@@ -31,7 +31,6 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
-import com.badlogic.gdx.tests.g3d.BaseG3dHudTest.CollapsableWindow;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class BitmapFontTest extends GdxTest {
@@ -57,13 +56,14 @@ public class BitmapFontTest extends GdxTest {
 		stage = new Stage();
 
 		Skin skin = new Skin(Gdx.files.internal(""data/uiskin.json""));
-		
+
 		BitmapFont labelFont = skin.get(""default-font"", BitmapFont.class);
 		labelFont.setMarkupEnabled(true);
 
-		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations (they are silently ignored).
+		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
+		// They are silently ignored, as expected.
 		Label label = new Label(""<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][]>>"", skin);
-		
+
 		label.setPosition(200, 200);
 		stage.addActor(label);
 
@@ -146,7 +146,7 @@ public class BitmapFontTest extends GdxTest {
 		renderer.setColor(Color.BLACK);
 		renderer.rect(x, viewHeight - y, x + alignmentWidth, 300);
 		renderer.end();
-		
+
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
 	}
 This is the generated message: Code formatted and imports organized. Here is the code diff: diff --git a/BazelCppRuleClasses_old.java b/BazelCppRuleClasses_new.java
index 9363b34..7115da9 100644
--- a/BazelCppRuleClasses_old.java
+++ b/BazelCppRuleClasses_new.java
@@ -259,8 +259,7 @@ public class BazelCppRuleClasses {
           so be careful about header files included elsewhere.</p>
           <!-- #END_BLAZE_RULE.ATTRIBUTE -->*/
           .add(attr(""copts"", STRING_LIST))
-          .add(attr(""$stl"", LABEL).value(
-              env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"")))
+          .add(attr(""$stl"", LABEL).value(env.getLabel(""//tools/cpp:stl"")))
           .add(attr("":stl"", LABEL).value(STL))
           .build();
     }
@@ -533,7 +532,7 @@ public class BazelCppRuleClasses {
               // Every cc_rule depends implicitly on STL to make
               // sure that the correct headers are used for inclusion. The only exception is
               // STL itself to avoid cycles in the dependency graph.
-              Label stl = env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"");
+              Label stl = env.getLabel(""//tools/cpp:stl"");
               return rule.getLabel().equals(stl) ? null : stl;
             }
           }))
 This is the generated message: Fix broken resolution of STL sources through @bazel_tools.

Includes an integration test for bazel + stl and objc -> cc deps.

Based on patched work by cparsons@.

--
MOS_MIGRATED_REVID=106946039 Here is the code diff: diff --git a/ServerAdmin_old.java b/ServerAdmin_new.java
index e52711e..f5f3580 100644
--- a/ServerAdmin_old.java
+++ b/ServerAdmin_new.java
@@ -487,12 +487,12 @@ public class ServerAdmin implements GhidraLaunchable {
 		System.err.println(""\nSupported commands:"");
 		System.err.println(""  -add <sid> [--p]"");
 		System.err.println(
-			""      Add a new user to the server identified by their sid identifier [-p prompt for password]"");
+			""      Add a new user to the server identified by their sid identifier [--p prompt for password]"");
 		System.err.println(""  -remove <sid>"");
 		System.err.println(""      Remove the specified user from the server's user list"");
 		System.err.println(""  -reset <sid> [--p]"");
 		System.err.println(
-			""      Reset the specified user's server login password [-p prompt for password]"");
+			""      Reset the specified user's server login password [--p prompt for password]"");
 		System.err.println(""  -dn <sid> \""<dname>\"""");
 		System.err.println(
 			""      When PKI authentication is used, add the specified X500 Distinguished Name for a user"");
 This is the generated message: GT-360 corrected usage text Here is the code diff: diff --git a/Launcher_old.java b/Launcher_new.java
index 2511a96..c69a55f 100644
--- a/Launcher_old.java
+++ b/Launcher_new.java
@@ -103,7 +103,10 @@ public abstract class Launcher {
         StringBuffer buf = new StringBuffer();
         if (workDir != null) {
             buf.append('[');
-            buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
+            if(showFullPath)
+                buf.append(workDir.getRemote());
+            else
+                buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
             buf.append(""] "");
         }
         buf.append('$');
@@ -144,4 +147,9 @@ public abstract class Launcher {
             return m;
         }
     }
+
+    /**
+     * Debug option to display full current path instead of just the last token.
+     */
+    public static boolean showFullPath = false;
 }
 This is the generated message:"
"You are acting as a commit message generator. Your task is to create an appropriate commit message for the given code diff. The commit message should be clear, informative, and brief. Please refrain from adding any explanations or additional words. Here is the code diff: diff --git a/JavaCompilationHelper_old.java b/JavaCompilationHelper_new.java
index 08ca268..8791145 100644
--- a/JavaCompilationHelper_old.java
+++ b/JavaCompilationHelper_new.java
@@ -279,6 +279,8 @@ public final class JavaCompilationHelper extends BaseJavaCompilationHelper {
     builder.addDirectJars(attributes.getDirectJars());
     builder.setRuleKind(attributes.getRuleKind());
     builder.setTargetLabel(attributes.getTargetLabel());
+    builder.setJavaBaseInputs(getHostJavabaseInputsNonStatic(ruleContext));
+    builder.setJavacJar(getLangtoolsJar());
     builder.build();
 
     artifactBuilder.setCompileTimeDependencies(headerDeps);
diff --git a/JavaHeaderCompileActionBuilder_old.java b/JavaHeaderCompileActionBuilder_new.java
index 02d01cb..02b2a34 100644
--- a/JavaHeaderCompileActionBuilder_old.java
+++ b/JavaHeaderCompileActionBuilder_new.java
@@ -20,7 +20,6 @@ import com.google.common.collect.ImmutableList;
 import com.google.devtools.build.lib.actions.Artifact;
 import com.google.devtools.build.lib.actions.ParameterFile.ParameterFileType;
 import com.google.devtools.build.lib.actions.ResourceSet;
-import com.google.devtools.build.lib.analysis.RuleConfiguredTarget.Mode;
 import com.google.devtools.build.lib.analysis.RuleContext;
 import com.google.devtools.build.lib.analysis.actions.CommandLine;
 import com.google.devtools.build.lib.analysis.actions.CustomCommandLine;
@@ -75,6 +74,8 @@ public class JavaHeaderCompileActionBuilder {
   private ImmutableList<String> javacOpts;
   private List<Artifact> processorPath = new ArrayList<>();
   private List<String> processorNames = new ArrayList<>();
+  private NestedSet<Artifact> javabaseInputs;
+  private Artifact javacJar;
 
   /** Creates a builder using the configuration of the rule as the action configuration. */
   public JavaHeaderCompileActionBuilder(RuleContext ruleContext) {
@@ -204,6 +205,20 @@ public class JavaHeaderCompileActionBuilder {
     return this;
   }
 
+  /** Sets the javabase inputs. */
+  public JavaHeaderCompileActionBuilder setJavaBaseInputs(NestedSet<Artifact> javabaseInputs) {
+    checkNotNull(javabaseInputs, ""javabaseInputs must not be null"");
+    this.javabaseInputs = javabaseInputs;
+    return this;
+  }
+
+  /** Sets the javac jar. */
+  public JavaHeaderCompileActionBuilder setJavacJar(Artifact javacJar) {
+    checkNotNull(javacJar, ""javacJar must not be null"");
+    this.javacJar = javacJar;
+    return this;
+  }
+
   /** Builds and registers the {@link SpawnAction} for a header compilation. */
   public void build() {
     checkNotNull(outputDepsProto, ""outputDepsProto must not be null"");
@@ -229,7 +244,7 @@ public class JavaHeaderCompileActionBuilder {
     builder.useParameterFile(ParameterFileType.SHELL_QUOTED);
     builder.setCommandLine(buildCommandLine(ruleContext.getConfiguration().getHostPathSeparator()));
 
-    builder.addTransitiveInputs(JavaHelper.getHostJavabaseInputs(ruleContext));
+    builder.addTransitiveInputs(javabaseInputs);
     builder.addInputs(classpathEntries);
     builder.addInputs(bootclasspathEntries);
     builder.addInputs(processorPath);
@@ -238,14 +253,13 @@ public class JavaHeaderCompileActionBuilder {
     builder.addInputs(directJars);
     builder.addInputs(compileTimeDependencyArtifacts);
 
-    Artifact langtools = ruleContext.getPrerequisiteArtifact(""$java_langtools"", Mode.HOST);
-    builder.addTool(langtools);
+    builder.addTool(javacJar);
 
     JavaToolchainProvider javaToolchain = JavaToolchainProvider.fromRuleContext(ruleContext);
     List<String> jvmArgs =
         ImmutableList.<String>builder()
             .addAll(javaToolchain.getJavacJvmOptions())
-            .add(""-Xbootclasspath/p:"" + langtools.getExecPath().getPathString())
+            .add(""-Xbootclasspath/p:"" + javacJar.getExecPath().getPathString())
             .build();
     builder.setJarExecutable(
         ruleContext.getHostConfiguration().getFragment(Jvm.class).getJavaExecutable(),
 This is the generated message: Update header compilation to handle implicit attribute suffixes

--
MOS_MIGRATED_REVID=117153381 Here is the code diff: diff --git a/BitmapFontCache_old.java b/BitmapFontCache_new.java
index 099c534..62fe276 100644
--- a/BitmapFontCache_old.java
+++ b/BitmapFontCache_new.java
@@ -22,7 +22,6 @@ import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.Glyph;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.HAlignment;
 import com.badlogic.gdx.graphics.g2d.BitmapFont.TextBounds;
-import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.utils.Array;
 import com.badlogic.gdx.utils.GdxRuntimeException;
 import com.badlogic.gdx.utils.IntArray;
@@ -47,8 +46,9 @@ public class BitmapFontCache {
 			return new ColorChunk();
 		}
 	};
+
 	private Array<ColorChunk> colorChunks;
-	
+
 	private int[] idx;
 	/** Used internally to ensure a correct capacity for multi-page font vertex data. */
 	private int[] tmpGlyphCount;
@@ -138,14 +138,12 @@ public class BitmapFontCache {
 		return color;
 	}
 
-	private int updateCurrentChunk(int lastChunkIndex, Color tint) {
+	private int updateCurrentChunk (int lastChunkIndex, Color tint) {
 		lastChunkIndex++;
 		if (colorChunks.size <= lastChunkIndex) {
-			if (colorChunks.size <= 0)
-				currentChunkColor.set(tint);
+			if (colorChunks.size <= 0) currentChunkColor.set(tint);
 			currentChunkEndIndex = Integer.MAX_VALUE;
-		}
-		else {
+		} else {
 			ColorChunk cc = colorChunks.get(lastChunkIndex);
 			if (currentChunkEndIndex == cc.endIndex)
 				lastChunkIndex = updateCurrentChunk(lastChunkIndex, tint);
@@ -166,7 +164,7 @@ public class BitmapFontCache {
 			if (font.markupEnabled) {
 				int lastChunkIndex = updateCurrentChunk(-1, tint);
 				float color = currentChunkColor.toFloatBits();
-				int ci = 0;  // character index
+				int ci = 0; // character index
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
@@ -177,15 +175,14 @@ public class BitmapFontCache {
 							}
 						}
 						vertices[i] = color;
-					}					
+					}
 				}
-			}
-			else {
+			} else {
 				for (int j = 0, length = vertexData.length; j < length; j++) {
 					float[] vertices = vertexData[j];
 					for (int i = 2, n = idx[j]; i < n; i += 5) {
 						vertices[i] = floatTint;
-					}					
+					}
 				}
 			}
 		}
@@ -520,8 +517,7 @@ public class BitmapFontCache {
 		Glyph lastGlyph = null;
 		BitmapFontData data = font.data;
 		textChanged = start < end;
-		if (font.markupEnabled && colorChunks.size == 0)
-			colorChunks.add(obtainColorChunk(this.color, -1));
+		if (font.markupEnabled && colorChunks.size == 0) colorChunks.add(obtainColorChunk(this.color, -1));
 		if (data.scaleX == 1 && data.scaleY == 1) {
 			while (start < end) {
 				char ch = str.charAt(start++);
@@ -870,11 +866,11 @@ public class BitmapFontCache {
 	public float[] getVertices (int page) {
 		return vertexData[page];
 	}
-	
+
 	private static class ColorChunk implements Poolable {
 		float color;
 		int endIndex;
-		int popIndex;  // needed to emulate the color stack
+		int popIndex; // needed to emulate the color stack
 
 		ColorChunk () {
 			this.endIndex = Integer.MAX_VALUE;
diff --git a/BitmapFontTest_old.java b/BitmapFontTest_new.java
index 3b193ac..637a21c 100644
--- a/BitmapFontTest_old.java
+++ b/BitmapFontTest_new.java
@@ -31,7 +31,6 @@ import com.badlogic.gdx.scenes.scene2d.Stage;
 import com.badlogic.gdx.scenes.scene2d.ui.Label;
 import com.badlogic.gdx.scenes.scene2d.ui.Skin;
 import com.badlogic.gdx.scenes.scene2d.ui.Window;
-import com.badlogic.gdx.tests.g3d.BaseG3dHudTest.CollapsableWindow;
 import com.badlogic.gdx.tests.utils.GdxTest;
 
 public class BitmapFontTest extends GdxTest {
@@ -57,13 +56,14 @@ public class BitmapFontTest extends GdxTest {
 		stage = new Stage();
 
 		Skin skin = new Skin(Gdx.files.internal(""data/uiskin.json""));
-		
+
 		BitmapFont labelFont = skin.get(""default-font"", BitmapFont.class);
 		labelFont.setMarkupEnabled(true);
 
-		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations (they are silently ignored).
+		// Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
+		// They are silently ignored, as expected.
 		Label label = new Label(""<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][]>>"", skin);
-		
+
 		label.setPosition(200, 200);
 		stage.addActor(label);
 
@@ -146,7 +146,7 @@ public class BitmapFontTest extends GdxTest {
 		renderer.setColor(Color.BLACK);
 		renderer.rect(x, viewHeight - y, x + alignmentWidth, 300);
 		renderer.end();
-		
+
 		stage.act(Gdx.graphics.getDeltaTime());
 		stage.draw();
 	}
 This is the generated message: Code formatted and imports organized. Here is the code diff: diff --git a/BazelCppRuleClasses_old.java b/BazelCppRuleClasses_new.java
index 9363b34..7115da9 100644
--- a/BazelCppRuleClasses_old.java
+++ b/BazelCppRuleClasses_new.java
@@ -259,8 +259,7 @@ public class BazelCppRuleClasses {
           so be careful about header files included elsewhere.</p>
           <!-- #END_BLAZE_RULE.ATTRIBUTE -->*/
           .add(attr(""copts"", STRING_LIST))
-          .add(attr(""$stl"", LABEL).value(
-              env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"")))
+          .add(attr(""$stl"", LABEL).value(env.getLabel(""//tools/cpp:stl"")))
           .add(attr("":stl"", LABEL).value(STL))
           .build();
     }
@@ -533,7 +532,7 @@ public class BazelCppRuleClasses {
               // Every cc_rule depends implicitly on STL to make
               // sure that the correct headers are used for inclusion. The only exception is
               // STL itself to avoid cycles in the dependency graph.
-              Label stl = env.getLabel(Constants.TOOLS_REPOSITORY + ""//tools/cpp:stl"");
+              Label stl = env.getLabel(""//tools/cpp:stl"");
               return rule.getLabel().equals(stl) ? null : stl;
             }
           }))
 This is the generated message: Fix broken resolution of STL sources through @bazel_tools.

Includes an integration test for bazel + stl and objc -> cc deps.

Based on patched work by cparsons@.

--
MOS_MIGRATED_REVID=106946039 Here is the code diff: diff --git a/ServerAdmin_old.java b/ServerAdmin_new.java
index e52711e..f5f3580 100644
--- a/ServerAdmin_old.java
+++ b/ServerAdmin_new.java
@@ -487,12 +487,12 @@ public class ServerAdmin implements GhidraLaunchable {
 		System.err.println(""\nSupported commands:"");
 		System.err.println(""  -add <sid> [--p]"");
 		System.err.println(
-			""      Add a new user to the server identified by their sid identifier [-p prompt for password]"");
+			""      Add a new user to the server identified by their sid identifier [--p prompt for password]"");
 		System.err.println(""  -remove <sid>"");
 		System.err.println(""      Remove the specified user from the server's user list"");
 		System.err.println(""  -reset <sid> [--p]"");
 		System.err.println(
-			""      Reset the specified user's server login password [-p prompt for password]"");
+			""      Reset the specified user's server login password [--p prompt for password]"");
 		System.err.println(""  -dn <sid> \""<dname>\"""");
 		System.err.println(
 			""      When PKI authentication is used, add the specified X500 Distinguished Name for a user"");
 This is the generated message: GT-360 corrected usage text Here is the code diff: diff --git a/Launcher_old.java b/Launcher_new.java
index 2511a96..c69a55f 100644
--- a/Launcher_old.java
+++ b/Launcher_new.java
@@ -103,7 +103,10 @@ public abstract class Launcher {
         StringBuffer buf = new StringBuffer();
         if (workDir != null) {
             buf.append('[');
-            buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
+            if(showFullPath)
+                buf.append(workDir.getRemote());
+            else
+                buf.append(workDir.getRemote().replaceFirst(""^.+[/\\\\]"", """"));
             buf.append(""] "");
         }
         buf.append('$');
@@ -144,4 +147,9 @@ public abstract class Launcher {
             return m;
         }
     }
+
+    /**
+     * Debug option to display full current path instead of just the last token.
+     */
+    public static boolean showFullPath = false;
 }
 This is the generated message:"
